"""
üöÄ Ultimate Binance-Style BTC Chart System
- Î∞îÏù¥ÎÇ∏Ïä§Ï≤òÎüº 1m, 5m, 15m, 1h, 4h, 1d, 1w ÏãúÍ∞ÑÏ∂ï ÏßÄÏõê
- 6Í∞úÏõî ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Í≥†Ï†ïÌôïÎèÑ ÏòàÏ∏°
- Ïã§ÏãúÍ∞Ñ API Ïó∞Îèô
- 95%+ Ï†ïÌôïÎèÑ Î™©Ìëú
"""

import os
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import warnings
warnings.filterwarnings('ignore')

# ÌïÑÏàò ÎùºÏù¥Î∏åÎü¨Î¶¨
try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import plotly.express as px
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False
    print("‚ùå Plotly ÎØ∏ÏÑ§Ïπò - pip install plotly")
    exit()

try:
    from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, ExtraTreesRegressor
    from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet
    from sklearn.svm import SVR
    from sklearn.neural_network import MLPRegressor
    from sklearn.preprocessing import StandardScaler, RobustScaler
    from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error
    from sklearn.model_selection import TimeSeriesSplit
    import ta  # Í∏∞Ïà†Ï†Å ÏßÄÌëú
    import yfinance as yf  # Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞
    SKLEARN_AVAILABLE = True
except ImportError:
    SKLEARN_AVAILABLE = False
    print("‚ùå ÌïÑÏàò ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎØ∏ÏÑ§Ïπò")
    print("pip install scikit-learn ta yfinance")
    exit()

class UltimateBinanceChart:
    """Ultimate Binance-Style Chart System"""
    
    def __init__(self):
        self.base_path = "/Users/parkyoungjun/Desktop/BTC_Analysis_System"
        self.timeseries_path = os.path.join(self.base_path, "timeseries_data")
        self.historical_path = os.path.join(self.base_path, "historical_data")
        
        # ÏãúÍ∞ÑÏ∂ï Ï†ïÏùò (Î∞îÏù¥ÎÇ∏Ïä§ Ïä§ÌÉÄÏùº)
        self.timeframes = {
            '1m': {'minutes': 1, 'points': 60, 'label': '1Î∂Ñ'},
            '5m': {'minutes': 5, 'points': 60, 'label': '5Î∂Ñ'},
            '15m': {'minutes': 15, 'points': 96, 'label': '15Î∂Ñ'},
            '1h': {'minutes': 60, 'points': 168, 'label': '1ÏãúÍ∞Ñ'},
            '4h': {'minutes': 240, 'points': 180, 'label': '4ÏãúÍ∞Ñ'},
            '1d': {'minutes': 1440, 'points': 365, 'label': '1Ïùº'},
            '1w': {'minutes': 10080, 'points': 52, 'label': '1Ï£º'}
        }
        
        # Í≥†Í∏â Î™®Îç∏ ÏïôÏÉÅÎ∏î
        self.models = {}
        self.accuracy_scores = {}
        
        # ÏãúÏä§ÌÖú Ï†ïÌôïÎèÑ Ï∂îÏ†Å
        self.system_accuracy = {
            'price_accuracy': 0,
            'direction_accuracy': 0,
            'trend_accuracy': 0,
            'volatility_accuracy': 0
        }
    
    def get_realtime_data(self, symbol: str = "BTC-USD", period: str = "6mo", interval: str = "1h") -> pd.DataFrame:
        """Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞"""
        try:
            print(f"üì° Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Îäî Ï§ë... ({symbol}, {interval})")
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period, interval=interval)
            
            if df.empty:
                print("‚ö†Ô∏è yfinance Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©")
                return self.load_local_data()
            
            df = df.reset_index()
            df.columns = [col.lower() for col in df.columns]
            
            # ÌïÑÏàò Ïª¨Îüº Î≥ÄÌôò
            if 'date' in df.columns:
                df['timestamp'] = pd.to_datetime(df['date'])
            elif 'datetime' in df.columns:
                df['timestamp'] = pd.to_datetime(df['datetime'])
            
            df['price'] = df['close']
            
            print(f"‚úÖ Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞: {len(df)}Í∞ú Ìè¨Ïù∏Ìä∏")
            return df
            
        except Exception as e:
            print(f"‚ö†Ô∏è Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïã§Ìå®: {e}")
            return self.load_local_data()
    
    def load_local_data(self) -> pd.DataFrame:
        """Î°úÏª¨ 6Í∞úÏõî Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            print("üìä Î°úÏª¨ 6Í∞úÏõî Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë...")
            
            data_files = {
                'price': 'btc_price.csv',
                'volume': 'btc_volume.csv',
                'market_cap': 'btc_market_cap.csv',
                'active_addresses': 'active_addresses.csv'
            }
            
            master_df = None
            
            for data_type, filename in data_files.items():
                filepath = os.path.join(self.timeseries_path, filename)
                if os.path.exists(filepath):
                    df = pd.read_csv(filepath)
                    if 'timestamp' in df.columns and 'value' in df.columns:
                        df['timestamp'] = pd.to_datetime(df['timestamp'])
                        df = df.rename(columns={'value': data_type})
                        df = df[['timestamp', data_type]].dropna()
                        
                        if master_df is None:
                            master_df = df
                        else:
                            master_df = master_df.merge(df, on='timestamp', how='outer')
            
            if master_df is not None:
                master_df = master_df.sort_values('timestamp').reset_index(drop=True)
                for col in master_df.columns:
                    if col != 'timestamp':
                        master_df[col] = master_df[col].interpolate(method='linear')
                
                # Í∞ÄÏÉÅÏùò OHLC Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùÑ Í≤ΩÏö∞)
                if 'open' not in master_df.columns:
                    master_df['open'] = master_df['price'] * (1 + np.random.normal(0, 0.001, len(master_df)))
                    master_df['high'] = master_df['price'] * (1 + np.abs(np.random.normal(0, 0.005, len(master_df))))
                    master_df['low'] = master_df['price'] * (1 - np.abs(np.random.normal(0, 0.005, len(master_df))))
                    master_df['close'] = master_df['price']
                
                print(f"‚úÖ Î°úÏª¨ Îç∞Ïù¥ÌÑ∞: {len(master_df)}Í∞ú Ìè¨Ïù∏Ìä∏")
                return master_df
            
            return pd.DataFrame()
            
        except Exception as e:
            print(f"‚ùå Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            return pd.DataFrame()
    
    def calculate_ultra_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Ï¥àÍ≥†Í∏â Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (Ï†ïÌôïÎèÑ Ìñ•ÏÉÅÏö©)"""
        try:
            print("üîß Ï¥àÍ≥†Í∏â ÏßÄÌëú Í≥ÑÏÇ∞ Ï§ë...")
            
            # Í∏∞Î≥∏ ÏßÄÌëúÎì§
            for period in [7, 14, 21, 30, 50, 100, 200]:
                df[f'sma_{period}'] = ta.trend.sma_indicator(df['price'], window=period)
                df[f'ema_{period}'] = ta.trend.ema_indicator(df['price'], window=period)
            
            # RSI Îã§Ï§ë Í∏∞Í∞Ñ
            for period in [7, 14, 21, 28]:
                df[f'rsi_{period}'] = ta.momentum.rsi(df['price'], window=period)
            
            # MACD Î≥ÄÌòï
            for fast, slow in [(12, 26), (5, 35), (8, 21)]:
                macd = ta.trend.MACD(df['price'], window_fast=fast, window_slow=slow)
                df[f'macd_{fast}_{slow}'] = macd.macd()
                df[f'macd_signal_{fast}_{slow}'] = macd.macd_signal()
                df[f'macd_hist_{fast}_{slow}'] = macd.macd_diff()
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Îã§Ï§ë
            for period in [20, 30]:
                bb = ta.volatility.BollingerBands(df['price'], window=period)
                df[f'bb_upper_{period}'] = bb.bollinger_hband()
                df[f'bb_lower_{period}'] = bb.bollinger_lband()
                df[f'bb_width_{period}'] = bb.bollinger_wband()
                df[f'bb_pband_{period}'] = bb.bollinger_pband()
            
            # Stochastic
            stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'])
            df['stoch_k'] = stoch.stoch()
            df['stoch_d'] = stoch.stoch_signal()
            
            # Williams %R
            for period in [14, 28]:
                df[f'williams_r_{period}'] = ta.momentum.williams_r(df['high'], df['low'], df['close'], lbp=period)
            
            # ATR (Average True Range)
            for period in [14, 21]:
                df[f'atr_{period}'] = ta.volatility.average_true_range(df['high'], df['low'], df['close'], window=period)
            
            # ADX (Average Directional Index)
            adx = ta.trend.ADXIndicator(df['high'], df['low'], df['close'])
            df['adx'] = adx.adx()
            df['adx_pos'] = adx.adx_pos()
            df['adx_neg'] = adx.adx_neg()
            
            # CCI (Commodity Channel Index)
            for period in [20, 40]:
                df[f'cci_{period}'] = ta.trend.cci(df['high'], df['low'], df['close'], window=period)
            
            # OBV (On Balance Volume)
            if 'volume' in df.columns:
                df['obv'] = ta.volume.on_balance_volume(df['close'], df['volume'])
                df['obv_ma'] = df['obv'].rolling(20).mean()
                
                # Volume indicators
                df['volume_sma'] = df['volume'].rolling(20).mean()
                df['volume_ratio'] = df['volume'] / df['volume_sma']
                
                # VWAP
                df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()
            
            # Ichimoku
            ichimoku = ta.trend.IchimokuIndicator(df['high'], df['low'])
            df['ichimoku_a'] = ichimoku.ichimoku_a()
            df['ichimoku_b'] = ichimoku.ichimoku_b()
            df['ichimoku_base'] = ichimoku.ichimoku_base_line()
            df['ichimoku_conv'] = ichimoku.ichimoku_conversion_line()
            
            # ÌååÏÉù ÏßÄÌëúÎì§
            df['price_ma_ratio'] = df['price'] / df['sma_50']
            df['rsi_divergence'] = df['rsi_14'] - df['rsi_14'].rolling(14).mean()
            df['momentum'] = df['price'].pct_change(10)
            df['volatility'] = df['price'].rolling(20).std() / df['price'].rolling(20).mean()
            
            # Ìä∏Î†åÎìú Í∞ïÎèÑ
            df['trend_strength'] = abs(df['price'] - df['sma_50']) / df['sma_50']
            
            # ÏßÄÏßÄ/Ï†ÄÌï≠ Î†àÎ≤®
            df['resistance'] = df['high'].rolling(20).max()
            df['support'] = df['low'].rolling(20).min()
            df['price_position'] = (df['price'] - df['support']) / (df['resistance'] - df['support'])
            
            print(f"‚úÖ Ï¥àÍ≥†Í∏â ÏßÄÌëú Í≥ÑÏÇ∞ ÏôÑÎ£å: {len(df.columns)}Í∞ú ÌîºÏ≤ò")
            return df
            
        except Exception as e:
            print(f"‚ùå ÏßÄÌëú Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return df
    
    def train_ultra_models(self, df: pd.DataFrame, timeframe: str) -> Dict:
        """Ï¥àÏ†ïÎ∞Ä Î™®Îç∏ ÌõàÎ†® (95%+ Ï†ïÌôïÎèÑ Î™©Ìëú)"""
        try:
            print(f"ü§ñ {timeframe} Ï¥àÏ†ïÎ∞Ä Î™®Îç∏ ÌõàÎ†® Ï§ë...")
            
            # ÌîºÏ≤ò ÏÑ†ÌÉù
            feature_cols = []
            for col in df.columns:
                if col not in ['timestamp', 'date', 'price', 'close', 'open', 'high', 'low'] and df[col].notna().sum() > len(df) * 0.7:
                    feature_cols.append(col)
            
            if len(feature_cols) < 10:
                print("‚ö†Ô∏è ÌîºÏ≤ò Î∂ÄÏ°±")
                return {}
            
            print(f"üìä ÏÑ†ÌÉùÎêú ÌîºÏ≤ò: {len(feature_cols)}Í∞ú")
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            df_clean = df[['price'] + feature_cols].dropna()
            
            if len(df_clean) < 50:
                print("‚ùå ÌõàÎ†® Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±")
                return {}
            
            # Ïà´ÏûêÍ∞Ä ÏïÑÎãå Ïª¨Îüº Ï†úÍ±∞
            numeric_features = []
            for col in feature_cols:
                if pd.api.types.is_numeric_dtype(df_clean[col]):
                    numeric_features.append(col)
            
            feature_cols = numeric_features
            
            # ÌÉÄÍ≤ü ÏÉùÏÑ± (Îã§Ïùå Ï∫îÎì§ Í∞ÄÍ≤©)
            X = df_clean[feature_cols].iloc[:-1].reset_index(drop=True)
            y = df_clean['price'].iloc[1:].reset_index(drop=True)
            
            # TimeSeriesSplitÏúºÎ°ú ÍµêÏ∞® Í≤ÄÏ¶ù
            tscv = TimeSeriesSplit(n_splits=5)
            
            # Îã§ÏñëÌïú Ïä§ÏºÄÏùºÎü¨ ÌÖåÏä§Ìä∏
            scalers = {
                'standard': StandardScaler(),
                'robust': RobustScaler()
            }
            
            # Îã§ÏñëÌïú Î™®Îç∏Îì§
            models = {
                'RandomForest': RandomForestRegressor(
                    n_estimators=200, 
                    max_depth=20,
                    min_samples_split=5,
                    min_samples_leaf=2,
                    random_state=42,
                    n_jobs=-1
                ),
                'ExtraTrees': ExtraTreesRegressor(
                    n_estimators=200,
                    max_depth=20,
                    random_state=42,
                    n_jobs=-1
                ),
                'GradientBoosting': GradientBoostingRegressor(
                    n_estimators=200,
                    learning_rate=0.05,
                    max_depth=10,
                    random_state=42
                ),
                'SVR': SVR(kernel='rbf', C=100, gamma=0.001),
                'ElasticNet': ElasticNet(alpha=0.1, l1_ratio=0.5),
                'MLP': MLPRegressor(
                    hidden_layer_sizes=(100, 50, 25),
                    activation='relu',
                    solver='adam',
                    max_iter=1000,
                    random_state=42
                )
            }
            
            best_models = []
            
            for scaler_name, scaler in scalers.items():
                X_scaled = scaler.fit_transform(X)
                
                for model_name, model in models.items():
                    try:
                        # ÍµêÏ∞® Í≤ÄÏ¶ù
                        scores = []
                        direction_scores = []
                        
                        for train_idx, test_idx in tscv.split(X_scaled):
                            X_train, X_test = X_scaled[train_idx], X_scaled[test_idx]
                            y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]
                            
                            model_copy = model.__class__(**model.get_params())
                            model_copy.fit(X_train, y_train)
                            y_pred = model_copy.predict(X_test)
                            
                            # ÌèâÍ∞Ä ÏßÄÌëú
                            mae = mean_absolute_error(y_test, y_pred)
                            mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
                            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
                            r2 = r2_score(y_test, y_pred)
                            
                            # Î∞©Ìñ• Ï†ïÌôïÎèÑ
                            if len(y_test) > 1:
                                actual_direction = np.diff(y_test.values)
                                pred_direction = np.diff(y_pred)
                                direction_acc = np.mean(np.sign(actual_direction) == np.sign(pred_direction))
                                direction_scores.append(direction_acc)
                            
                            scores.append({
                                'mae': mae,
                                'mape': mape,
                                'rmse': rmse,
                                'r2': r2
                            })
                        
                        # ÌèâÍ∑† Ï†êÏàò
                        avg_mae = np.mean([s['mae'] for s in scores])
                        avg_mape = np.mean([s['mape'] for s in scores])
                        avg_r2 = np.mean([s['r2'] for s in scores])
                        avg_direction = np.mean(direction_scores) if direction_scores else 0.5
                        
                        # ÏµúÏ¢Ö Î™®Îç∏ ÌõàÎ†®
                        model.fit(X_scaled, y)
                        
                        best_models.append({
                            'name': f'{model_name}_{scaler_name}',
                            'model': model,
                            'scaler': scaler,
                            'mae': avg_mae,
                            'mape': avg_mape,
                            'r2': avg_r2,
                            'direction_accuracy': avg_direction,
                            'features': feature_cols,
                            'score': avg_r2 * avg_direction  # Ï¢ÖÌï© Ï†êÏàò
                        })
                        
                        print(f"  ‚Ä¢ {model_name}_{scaler_name}: MAPE={avg_mape:.2f}%, R¬≤={avg_r2:.3f}, Î∞©Ìñ•={avg_direction:.1%}")
                        
                    except Exception as e:
                        continue
            
            # ÏÉÅÏúÑ 3Í∞ú Î™®Îç∏ ÏÑ†ÌÉù
            best_models = sorted(best_models, key=lambda x: x['score'], reverse=True)[:3]
            
            if best_models:
                best = best_models[0]
                print(f"üèÜ ÏµúÍ≥† Î™®Îç∏: {best['name']} (MAPE={best['mape']:.2f}%, Î∞©Ìñ•Ï†ïÌôïÎèÑ={best['direction_accuracy']:.1%})")
                
                # Ï†ïÌôïÎèÑ Ï†ÄÏû•
                self.accuracy_scores[timeframe] = {
                    'mape': best['mape'],
                    'direction': best['direction_accuracy'],
                    'r2': best['r2']
                }
            
            return {
                'models': best_models,
                'timeframe': timeframe,
                'data_points': len(X)
            }
            
        except Exception as e:
            print(f"‚ùå Î™®Îç∏ ÌõàÎ†® Ïã§Ìå®: {e}")
            return {}
    
    def predict_future(self, df: pd.DataFrame, model_info: Dict, periods: int) -> List[Dict]:
        """ÎØ∏Îûò ÏòàÏ∏° ÏÉùÏÑ±"""
        try:
            if not model_info or 'models' not in model_info:
                return []
            
            predictions = []
            models = model_info['models']
            
            # ÏµúÏã† Îç∞Ïù¥ÌÑ∞
            latest = df[models[0]['features']].iloc[-1:].values
            current_price = df['price'].iloc[-1]
            current_time = df['timestamp'].iloc[-1] if 'timestamp' in df.columns else datetime.now()
            
            for i in range(periods):
                pred_time = current_time + timedelta(minutes=self.timeframes[model_info['timeframe']]['minutes'] * (i + 1))
                
                # ÏïôÏÉÅÎ∏î ÏòàÏ∏°
                all_predictions = []
                for model_data in models:
                    try:
                        if model_data['scaler']:
                            features_scaled = model_data['scaler'].transform(latest)
                        else:
                            features_scaled = latest
                        
                        pred = model_data['model'].predict(features_scaled)[0]
                        all_predictions.append(pred)
                    except:
                        continue
                
                if all_predictions:
                    # Í∞ÄÏ§ë ÌèâÍ∑† (ÏÑ±Îä• Í∏∞Î∞ò)
                    weights = [m['score'] for m in models[:len(all_predictions)]]
                    total_weight = sum(weights)
                    weights = [w/total_weight for w in weights]
                    
                    predicted_price = np.average(all_predictions, weights=weights)
                    price_std = np.std(all_predictions)
                    
                    # Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
                    avg_accuracy = np.mean([m['direction_accuracy'] for m in models])
                    time_decay = 0.95 ** i  # ÏãúÍ∞ÑÏóê Îî∞Î•∏ Ïã†Î¢∞ÎèÑ Í∞êÏÜå
                    confidence = avg_accuracy * time_decay * 100
                    
                    predictions.append({
                        'time': pred_time,
                        'price': predicted_price,
                        'upper': predicted_price + price_std * 2,
                        'lower': predicted_price - price_std * 2,
                        'confidence': confidence
                    })
            
            return predictions
            
        except Exception as e:
            print(f"‚ùå ÏòàÏ∏° ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return []
    
    def create_binance_chart(self, timeframe: str = '1h', predict_periods: int = 24):
        """Î∞îÏù¥ÎÇ∏Ïä§ Ïä§ÌÉÄÏùº Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            print(f"\nüìä {timeframe} Î∞îÏù¥ÎÇ∏Ïä§ Ïä§ÌÉÄÏùº Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")
            
            # Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            interval_map = {
                '1m': '1m', '5m': '5m', '15m': '15m',
                '1h': '1h', '4h': '4h', '1d': '1d', '1w': '1wk'
            }
            
            df = self.get_realtime_data(interval=interval_map.get(timeframe, '1h'))
            if df.empty:
                print("‚ùå Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return None
            
            # ÏßÄÌëú Í≥ÑÏÇ∞
            df = self.calculate_ultra_indicators(df)
            
            # Î™®Îç∏ ÌõàÎ†®
            model_info = self.train_ultra_models(df, timeframe)
            
            # ÏòàÏ∏° ÏÉùÏÑ±
            predictions = self.predict_future(df, model_info, predict_periods)
            
            # Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = make_subplots(
                rows=4, cols=1,
                subplot_titles=(
                    f"BTC/USDT {self.timeframes[timeframe]['label']} Ï∞®Ìä∏",
                    "Í±∞ÎûòÎüâ",
                    "RSI & Ïä§ÌÜ†Ï∫êÏä§Ìã±",
                    "MACD"
                ),
                vertical_spacing=0.05,
                row_heights=[0.5, 0.15, 0.15, 0.15],
                specs=[[{"secondary_y": False}],
                       [{"secondary_y": False}],
                       [{"secondary_y": False}],
                       [{"secondary_y": False}]]
            )
            
            # 1. Ï∫îÎì§Ïä§Ìã± Ï∞®Ìä∏
            fig.add_trace(
                go.Candlestick(
                    x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                    open=df['open'],
                    high=df['high'],
                    low=df['low'],
                    close=df['close'],
                    name='BTC',
                    increasing_line_color='#26a69a',
                    decreasing_line_color='#ef5350'
                ),
                row=1, col=1
            )
            
            # Ïù¥ÎèôÌèâÍ∑†ÏÑ†
            for ma in [20, 50, 200]:
                if f'sma_{ma}' in df.columns:
                    fig.add_trace(
                        go.Scatter(
                            x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                            y=df[f'sma_{ma}'],
                            name=f'MA{ma}',
                            line=dict(width=1)
                        ),
                        row=1, col=1
                    )
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            if 'bb_upper_20' in df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['bb_upper_20'],
                        name='BB Upper',
                        line=dict(color='rgba(250,128,114,0.5)', width=1)
                    ),
                    row=1, col=1
                )
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['bb_lower_20'],
                        name='BB Lower',
                        line=dict(color='rgba(250,128,114,0.5)', width=1),
                        fill='tonexty',
                        fillcolor='rgba(250,128,114,0.1)'
                    ),
                    row=1, col=1
                )
            
            # ÏòàÏ∏° Ï∂îÍ∞Ä
            if predictions:
                pred_times = [p['time'] for p in predictions]
                pred_prices = [p['price'] for p in predictions]
                pred_upper = [p['upper'] for p in predictions]
                pred_lower = [p['lower'] for p in predictions]
                
                fig.add_trace(
                    go.Scatter(
                        x=pred_times,
                        y=pred_prices,
                        mode='lines+markers',
                        name='AI ÏòàÏ∏°',
                        line=dict(color='yellow', width=2, dash='dot'),
                        marker=dict(size=4)
                    ),
                    row=1, col=1
                )
                
                # ÏòàÏ∏° Ïã†Î¢∞Íµ¨Í∞Ñ
                fig.add_trace(
                    go.Scatter(
                        x=pred_times + pred_times[::-1],
                        y=pred_upper + pred_lower[::-1],
                        fill='toself',
                        fillcolor='rgba(255,255,0,0.1)',
                        line=dict(color='rgba(255,255,255,0)'),
                        name='ÏòàÏ∏° Î≤îÏúÑ',
                        hoverinfo='skip'
                    ),
                    row=1, col=1
                )
            
            # 2. Í±∞ÎûòÎüâ
            if 'volume' in df.columns:
                colors = ['red' if row['close'] < row['open'] else 'green' 
                         for _, row in df.iterrows()]
                fig.add_trace(
                    go.Bar(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['volume'],
                        name='Volume',
                        marker_color=colors,
                        opacity=0.7
                    ),
                    row=2, col=1
                )
            
            # 3. RSI & Ïä§ÌÜ†Ï∫êÏä§Ìã±
            if 'rsi_14' in df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['rsi_14'],
                        name='RSI',
                        line=dict(color='purple', width=1)
                    ),
                    row=3, col=1
                )
                
                # RSI Í≥ºÎß§Ïàò/Í≥ºÎß§ÎèÑ ÏÑ†
                fig.add_hline(y=70, line_dash="dash", line_color="red", row=3, col=1)
                fig.add_hline(y=30, line_dash="dash", line_color="green", row=3, col=1)
            
            if 'stoch_k' in df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['stoch_k'],
                        name='Stoch %K',
                        line=dict(color='orange', width=1)
                    ),
                    row=3, col=1
                )
            
            # 4. MACD
            if 'macd_12_26' in df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['macd_12_26'],
                        name='MACD',
                        line=dict(color='blue', width=1)
                    ),
                    row=4, col=1
                )
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['macd_signal_12_26'],
                        name='Signal',
                        line=dict(color='red', width=1)
                    ),
                    row=4, col=1
                )
                fig.add_trace(
                    go.Bar(
                        x=df['timestamp'] if 'timestamp' in df.columns else df.index,
                        y=df['macd_hist_12_26'],
                        name='Histogram',
                        marker_color='gray',
                        opacity=0.3
                    ),
                    row=4, col=1
                )
            
            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï (Î∞îÏù¥ÎÇ∏Ïä§ Îã§ÌÅ¨ ÌÖåÎßà)
            fig.update_layout(
                title={
                    'text': f"üöÄ BTC/USDT Professional Trading Chart - {timeframe}",
                    'x': 0.5,
                    'xanchor': 'center'
                },
                template='plotly_dark',
                height=1000,
                showlegend=True,
                hovermode='x unified',
                xaxis_rangeslider_visible=False,
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                )
            )
            
            # YÏ∂ï ÏÑ§Ï†ï
            fig.update_yaxes(title_text="Price (USDT)", row=1, col=1)
            fig.update_yaxes(title_text="Volume", row=2, col=1)
            fig.update_yaxes(title_text="RSI/Stoch", row=3, col=1)
            fig.update_yaxes(title_text="MACD", row=4, col=1)
            
            # XÏ∂ï ÏÑ§Ï†ï
            fig.update_xaxes(title_text="Time", row=4, col=1)
            
            # Ï∞®Ìä∏ Ï†ÄÏû•
            chart_path = os.path.join(self.base_path, f"binance_chart_{timeframe}.html")
            fig.write_html(chart_path, include_plotlyjs=True)
            
            print(f"‚úÖ Ï∞®Ìä∏ Ï†ÄÏû•: {chart_path}")
            
            # Ï†ïÌôïÎèÑ Î¶¨Ìè¨Ìä∏
            if timeframe in self.accuracy_scores:
                acc = self.accuracy_scores[timeframe]
                print(f"\nüéØ ÏãúÏä§ÌÖú Ï†ïÌôïÎèÑ:")
                print(f"  ‚Ä¢ MAPE: {acc['mape']:.2f}% (Í∞ÄÍ≤© Ïò§Ï∞®)")
                print(f"  ‚Ä¢ Î∞©Ìñ• Ï†ïÌôïÎèÑ: {acc['direction']:.1%}")
                print(f"  ‚Ä¢ R¬≤ Score: {acc['r2']:.3f}")
                print(f"  ‚Ä¢ Ï¢ÖÌï© Ï†ïÌôïÎèÑ: {(100 - acc['mape'] + acc['direction']*100) / 2:.1f}%")
            
            return chart_path
            
        except Exception as e:
            print(f"‚ùå Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return None
    
    def create_all_timeframes(self):
        """Î™®Îì† ÏãúÍ∞ÑÏ∂ï Ï∞®Ìä∏ ÏÉùÏÑ±"""
        results = {}
        
        for tf in ['1h', '4h', '1d']:  # Ï£ºÏöî ÏãúÍ∞ÑÏ∂ïÎßå
            print(f"\n{'='*60}")
            print(f"üìä {tf} Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")
            print(f"{'='*60}")
            
            path = self.create_binance_chart(timeframe=tf, predict_periods=24)
            if path:
                results[tf] = path
        
        return results

def main():
    """Î©îÏù∏ Ïã§Ìñâ"""
    print("üöÄ Ultimate Binance-Style BTC Chart System")
    print("="*80)
    
    system = UltimateBinanceChart()
    
    # ÏõêÌïòÎäî ÏãúÍ∞ÑÏ∂ï ÏÑ†ÌÉù
    print("\nÏãúÍ∞ÑÏ∂ï ÏÑ†ÌÉù:")
    print("1. 1ÏãúÍ∞Ñ (1h)")
    print("2. 4ÏãúÍ∞Ñ (4h)")
    print("3. 1Ïùº (1d)")
    print("4. Î™®Îì† ÏãúÍ∞ÑÏ∂ï")
    
    # Í∏∞Î≥∏Í∞í: 1ÏãúÍ∞Ñ
    choice = "1"
    
    if choice == "1":
        chart = system.create_binance_chart(timeframe='1h', predict_periods=48)
    elif choice == "2":
        chart = system.create_binance_chart(timeframe='4h', predict_periods=30)
    elif choice == "3":
        chart = system.create_binance_chart(timeframe='1d', predict_periods=30)
    else:
        charts = system.create_all_timeframes()
        print(f"\n‚úÖ ÏÉùÏÑ±Îêú Ï∞®Ìä∏: {list(charts.keys())}")
    
    # Î∏åÎùºÏö∞Ï†Ä Ïó¥Í∏∞
    try:
        import subprocess
        if choice in ["1", "2", "3"]:
            subprocess.run(["open", chart], check=True)
        else:
            for path in charts.values():
                subprocess.run(["open", path], check=True)
        print("\nüåê Ï∞®Ìä∏Í∞Ä Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïó¥Î†∏ÏäµÎãàÎã§!")
    except:
        pass
    
    print("\n" + "="*80)
    print("üéâ Ultimate Chart System ÏôÑÎ£å!")
    print("="*80)

if __name__ == "__main__":
    main()