"""
Í∂ÅÍ∑πÏùò BTC ÏòàÏ∏° Ï∞®Ìä∏ ÏãúÏä§ÌÖú
- 6Í∞úÏõî Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌôúÏö©
- ÏßÄÌëúÏôÄ Í∞ÄÍ≤©Ïùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ ÌïôÏäµ
- Ï†ÑÎ¨∏Ï†ÅÏù∏ Ï∞®Ìä∏ ÎîîÏûêÏù∏
- ÎÜíÏùÄ Ï†ïÌôïÎèÑÏùò ÏòàÏ∏°
"""

import os
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
import warnings
warnings.filterwarnings('ignore')

# Î®∏Ïã†Îü¨Îãù
try:
    from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
    from sklearn.linear_model import LinearRegression
    from sklearn.preprocessing import StandardScaler
    from sklearn.metrics import mean_absolute_error, r2_score
    from sklearn.model_selection import train_test_split
    ML_AVAILABLE = True
except ImportError:
    ML_AVAILABLE = False

# Ï∞®Ìä∏
try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import plotly.express as px
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

class UltimatePredictionChart:
    """Í∂ÅÍ∑πÏùò ÏòàÏ∏° Ï∞®Ìä∏ ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.base_path = "/Users/parkyoungjun/Desktop/BTC_Analysis_System"
        self.timeseries_path = os.path.join(self.base_path, "timeseries_data")
        
    def load_6month_timeseries_data(self) -> pd.DataFrame:
        """6Í∞úÏõî ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            print("üìä 6Í∞úÏõî ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë...")
            
            # ÌïµÏã¨ Îç∞Ïù¥ÌÑ∞ ÌååÏùºÎì§
            data_files = {
                'price': 'btc_price.csv',
                'volume': 'btc_volume.csv', 
                'market_cap': 'btc_market_cap.csv',
                'active_addresses': 'active_addresses.csv'
            }
            
            # Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è Î≥ëÌï©
            master_df = None
            
            for data_type, filename in data_files.items():
                filepath = os.path.join(self.timeseries_path, filename)
                if os.path.exists(filepath):
                    df = pd.read_csv(filepath)
                    if 'timestamp' in df.columns and 'value' in df.columns:
                        df['timestamp'] = pd.to_datetime(df['timestamp'])
                        df = df.rename(columns={'value': data_type})
                        df = df[['timestamp', data_type]].dropna()
                        
                        if master_df is None:
                            master_df = df
                        else:
                            master_df = master_df.merge(df, on='timestamp', how='outer')
                        
                        print(f"  ‚úÖ {data_type}: {len(df)}Í∞ú Ìè¨Ïù∏Ìä∏")
            
            if master_df is None or len(master_df) == 0:
                print("‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®")
                return pd.DataFrame()
            
            # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∏∞Ï§Ä Ï†ïÎ†¨
            master_df = master_df.sort_values('timestamp').reset_index(drop=True)
            
            # Í≤∞Ï∏°Ïπò Ï≤òÎ¶¨ (ÏÑ†Ìòï Î≥¥Í∞Ñ)
            for col in master_df.columns:
                if col != 'timestamp':
                    master_df[col] = master_df[col].interpolate(method='linear')
            
            # ÏµúÍ∑º 6Í∞úÏõî Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©
            six_months_ago = datetime.now() - timedelta(days=180)
            master_df = master_df[master_df['timestamp'] >= six_months_ago].reset_index(drop=True)
            
            print(f"‚úÖ ÌÜµÌï© Îç∞Ïù¥ÌÑ∞: {len(master_df)}Í∞ú Ìè¨Ïù∏Ìä∏")
            print(f"üìÖ Í∏∞Í∞Ñ: {master_df['timestamp'].min()} ~ {master_df['timestamp'].max()}")
            
            return master_df
            
        except Exception as e:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            return pd.DataFrame()
    
    def calculate_advanced_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Í≥†Í∏â Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            print("üîß Í≥†Í∏â ÏßÄÌëú Í≥ÑÏÇ∞ Ï§ë...")
            
            # Í∏∞Î≥∏ Ïù¥ÎèôÌèâÍ∑†
            df['sma_7'] = df['price'].rolling(window=7).mean()
            df['sma_21'] = df['price'].rolling(window=21).mean()
            df['sma_50'] = df['price'].rolling(window=50).mean()
            
            # ÏßÄÏàòÏù¥ÎèôÌèâÍ∑†
            df['ema_12'] = df['price'].ewm(span=12).mean()
            df['ema_26'] = df['price'].ewm(span=26).mean()
            
            # MACD
            df['macd'] = df['ema_12'] - df['ema_26']
            df['macd_signal'] = df['macd'].ewm(span=9).mean()
            df['macd_histogram'] = df['macd'] - df['macd_signal']
            
            # RSI
            delta = df['price'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['rsi'] = 100 - (100 / (1 + rs))
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            sma_20 = df['price'].rolling(window=20).mean()
            std_20 = df['price'].rolling(window=20).std()
            df['bb_upper'] = sma_20 + (std_20 * 2)
            df['bb_lower'] = sma_20 - (std_20 * 2)
            df['bb_width'] = df['bb_upper'] - df['bb_lower']
            df['bb_position'] = (df['price'] - df['bb_lower']) / df['bb_width']
            
            # Î≥ÄÎèôÏÑ± ÏßÄÌëú
            df['volatility'] = df['price'].pct_change().rolling(window=20).std() * np.sqrt(252)
            
            # Í∞ÄÍ≤© Î™®Î©òÌÖÄ
            df['momentum_1d'] = df['price'].pct_change(periods=1)
            df['momentum_7d'] = df['price'].pct_change(periods=7)
            df['momentum_21d'] = df['price'].pct_change(periods=21)
            
            # Ïò®Ï≤¥Ïù∏ ÏßÄÌëú (ÏûàÎäî Í≤ΩÏö∞)
            if 'active_addresses' in df.columns:
                df['addr_ma_7'] = df['active_addresses'].rolling(window=7).mean()
                df['addr_growth'] = df['active_addresses'].pct_change(periods=7)
            
            # Í±∞ÎûòÎüâ ÏßÄÌëú
            if 'volume' in df.columns:
                df['volume_ma_7'] = df['volume'].rolling(window=7).mean()
                df['volume_ratio'] = df['volume'] / df['volume_ma_7']
            
            # ÏãúÍ∞ÄÏ¥ùÏï° ÏßÄÌëú
            if 'market_cap' in df.columns:
                df['mcap_change'] = df['market_cap'].pct_change(periods=1)
            
            print(f"‚úÖ ÏßÄÌëú Í≥ÑÏÇ∞ ÏôÑÎ£å: {len(df.columns)}Í∞ú Ïª¨Îüº")
            
            return df
            
        except Exception as e:
            print(f"‚ùå ÏßÄÌëú Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return df
    
    def train_prediction_model(self, df: pd.DataFrame) -> Tuple[object, List[str], Dict]:
        """ÏòàÏ∏° Î™®Îç∏ ÌõàÎ†®"""
        if not ML_AVAILABLE:
            print("‚ùå scikit-learn ÎØ∏ÏÑ§Ïπò")
            return None, [], {}
        
        try:
            print("ü§ñ ÏòàÏ∏° Î™®Îç∏ ÌõàÎ†® Ï§ë...")
            
            # ÌîºÏ≤ò ÏÑ†ÌÉù (Ïà´Ïûê Ïª¨Îüº, Í≤∞Ï∏°Ïπò 50% ÎØ∏Îßå)
            feature_cols = []
            for col in df.columns:
                if col not in ['timestamp', 'price'] and df[col].dtype in ['float64', 'int64']:
                    if df[col].notna().sum() > len(df) * 0.5:
                        feature_cols.append(col)
            
            print(f"üìä ÏÑ†ÌÉùÎêú ÌîºÏ≤ò: {len(feature_cols)}Í∞ú")
            
            # Í≤∞Ï∏°Ïπò Ï†úÍ±∞
            df_clean = df[['price'] + feature_cols].dropna()
            
            if len(df_clean) < 100:
                print("‚ùå ÌõàÎ†® Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±")
                return None, [], {}
            
            print(f"‚úÖ ÌõàÎ†® Îç∞Ïù¥ÌÑ∞: {len(df_clean)}Í∞ú ÏÉòÌîå")
            
            # ÎØ∏Îûò Í∞ÄÍ≤© ÏòàÏ∏° (1Ïùº ÌõÑ)
            X = df_clean[feature_cols].iloc[:-1].reset_index(drop=True)  # ÎßàÏßÄÎßâ Ï†úÏô∏
            y = df_clean['price'].iloc[1:].reset_index(drop=True)        # 1Ïùº ÌõÑ Í∞ÄÍ≤©
            
            # ÌõàÎ†®/ÌÖåÏä§Ìä∏ Î∂ÑÌï† (ÏãúÍ≥ÑÏó¥ ÌäπÏÑ± Í≥†Î†§)
            split_idx = int(len(X) * 0.8)
            X_train = X.iloc[:split_idx].reset_index(drop=True)
            X_test = X.iloc[split_idx:].reset_index(drop=True)
            y_train = y.iloc[:split_idx].reset_index(drop=True)
            y_test = y.iloc[split_idx:].reset_index(drop=True)
            
            # Ïä§ÏºÄÏùºÎßÅ
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            # Ïó¨Îü¨ Î™®Îç∏ ÌÖåÏä§Ìä∏
            models = {
                'RandomForest': RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1),
                'GradientBoosting': GradientBoostingRegressor(n_estimators=100, random_state=42),
                'Linear': LinearRegression()
            }
            
            results = {}
            best_model = None
            best_score = float('inf')
            
            for name, model in models.items():
                # ÌõàÎ†®
                if name == 'Linear':
                    model.fit(X_train_scaled, y_train)
                    y_pred = model.predict(X_test_scaled)
                else:
                    model.fit(X_train, y_train)
                    y_pred = model.predict(X_test)
                
                # ÌèâÍ∞Ä
                mae = mean_absolute_error(y_test, y_pred)
                r2 = r2_score(y_test, y_pred)
                
                # Î∞©Ìñ•ÏÑ± Ï†ïÌôïÎèÑ
                actual_direction = (y_test.shift(-1) > y_test).iloc[:-1]
                pred_direction = (pd.Series(y_pred[:-1]) > y_test.iloc[:-1])
                direction_accuracy = (actual_direction == pred_direction).mean()
                
                results[name] = {
                    'model': model,
                    'mae': mae,
                    'r2': r2,
                    'direction_accuracy': direction_accuracy,
                    'scaler': scaler if name == 'Linear' else None
                }
                
                print(f"  ‚Ä¢ {name}: MAE=${mae:,.0f}, R¬≤={r2:.3f}, Î∞©Ìñ•Ï†ïÌôïÎèÑ={direction_accuracy:.1%}")
                
                # ÏµúÍ≥† Î™®Îç∏ ÏÑ†ÌÉù (MAE Í∏∞Ï§Ä)
                if mae < best_score:
                    best_score = mae
                    best_model = results[name]
            
            print(f"üèÜ ÏµúÍ≥† Î™®Îç∏: MAE ${best_score:,.0f}")
            
            return best_model, feature_cols, results
            
        except Exception as e:
            print(f"‚ùå Î™®Îç∏ ÌõàÎ†® Ïã§Ìå®: {e}")
            return None, [], {}
    
    def generate_future_predictions(self, df: pd.DataFrame, model_info: Tuple, 
                                   hours_ahead: int = 48) -> List[Dict]:
        """ÎØ∏Îûò ÏòàÏ∏° ÏÉùÏÑ±"""
        try:
            best_model, feature_cols, _ = model_info
            if not best_model:
                return []
            
            print(f"üîÆ {hours_ahead}ÏãúÍ∞Ñ ÏòàÏ∏° ÏÉùÏÑ± Ï§ë...")
            
            model = best_model['model']
            scaler = best_model['scaler']
            
            # ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î°ú ÏòàÏ∏°
            latest_features = df[feature_cols].iloc[-1:].values
            
            if scaler:
                latest_features = scaler.transform(latest_features)
            
            # ÌòÑÏû¨ Í∞ÄÍ≤©
            current_price = df['price'].iloc[-1]
            current_time = datetime.now()
            
            predictions = []
            
            # Îã®Ïàú ÏòàÏ∏° (Í∞úÏÑ† Í∞ÄÎä•)
            base_prediction = model.predict(latest_features)[0]
            
            for hour in range(1, hours_ahead + 1):
                # ÏãúÍ∞ÑÏóê Îî∞Î•∏ Î∂àÌôïÏã§ÏÑ± Ï¶ùÍ∞Ä
                uncertainty_factor = 1 + (hour / hours_ahead) * 0.1
                noise = np.random.normal(0, best_model['mae'] * uncertainty_factor * 0.1)
                
                predicted_price = base_prediction + noise
                
                # Ïã†Î¢∞ÎèÑ (ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ†ÏàòÎ°ù Í∞êÏÜå)
                confidence = best_model['direction_accuracy'] * (1 - hour * 0.01)
                confidence = max(confidence, 0.3)
                
                # Ïã†Î¢∞ Íµ¨Í∞Ñ
                margin = best_model['mae'] * uncertainty_factor
                
                predictions.append({
                    'hour': hour,
                    'timestamp': current_time + timedelta(hours=hour),
                    'price': predicted_price,
                    'confidence': confidence,
                    'upper_bound': predicted_price + margin,
                    'lower_bound': predicted_price - margin,
                    'change_from_current': ((predicted_price / current_price) - 1) * 100
                })
            
            print(f"‚úÖ ÏòàÏ∏° ÏôÑÎ£å: {len(predictions)}Í∞ú ÏãúÏ†ê")
            
            return predictions
            
        except Exception as e:
            print(f"‚ùå ÏòàÏ∏° ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return []
    
    def create_ultimate_chart(self, df: pd.DataFrame, predictions: List[Dict], 
                             model_results: Dict) -> str:
        """Í∂ÅÍ∑πÏùò Ï∞®Ìä∏ ÏÉùÏÑ±"""
        if not PLOTLY_AVAILABLE:
            print("‚ùå Plotly ÎØ∏ÏÑ§Ïπò")
            return ""
        
        try:
            print("üìä Í∂ÅÍ∑πÏùò Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")
            
            # ÏµúÍ∑º 60Ïùº Îç∞Ïù¥ÌÑ∞Îßå Ï∞®Ìä∏Ïóê ÌëúÏãú
            recent_df = df.tail(60).copy()
            current_time = datetime.now()
            
            # ÏòàÏ∏° Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            future_times = [p['timestamp'] for p in predictions]
            future_prices = [p['price'] for p in predictions]
            future_upper = [p['upper_bound'] for p in predictions]
            future_lower = [p['lower_bound'] for p in predictions]
            future_confidence = [p['confidence'] * 100 for p in predictions]
            
            # 5Îã®Í≥Ñ ÏÑúÎ∏åÌîåÎ°Ø
            fig = make_subplots(
                rows=5, cols=1,
                subplot_titles=(
                    "üíé BTC Í∞ÄÍ≤© & 6Í∞úÏõî ÌïôÏäµ Í∏∞Î∞ò AI ÏòàÏ∏°",
                    "üìä Í±∞ÎûòÎüâ & AI Ïã†Î¢∞ÎèÑ",
                    "üîç RSI & MACD ÏßÄÌëú",
                    "üìà Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú & Î≥ÄÎèôÏÑ±",
                    "üåê Ïò®Ï≤¥Ïù∏ ÏßÄÌëú (ÌôúÏÑ± Ï£ºÏÜå)"
                ),
                vertical_spacing=0.05,
                row_heights=[0.35, 0.2, 0.15, 0.15, 0.15]
            )
            
            # 1. Ïã§Ï†ú Í∞ÄÍ≤© (ÏµúÍ∑º 60Ïùº)
            fig.add_trace(
                go.Scatter(
                    x=recent_df['timestamp'],
                    y=recent_df['price'],
                    mode='lines',
                    name='Ïã§Ï†ú BTC Í∞ÄÍ≤©',
                    line=dict(color='#3498DB', width=2),
                    hovertemplate='<b>Ïã§Ï†ú Í∞ÄÍ≤©</b><br>%{x|%m/%d %H:%M}<br>$%{y:,.0f}<extra></extra>'
                ),
                row=1, col=1
            )
            
            # 2. Ïù¥ÎèôÌèâÍ∑†
            if 'sma_21' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['sma_21'],
                        mode='lines',
                        name='21Ïùº Ïù¥ÎèôÌèâÍ∑†',
                        line=dict(color='orange', width=1, dash='dash'),
                        hovertemplate='<b>21Ïùº MA</b><br>%{x|%m/%d}<br>$%{y:,.0f}<extra></extra>'
                    ),
                    row=1, col=1
                )
            
            # 3. ÌòÑÏû¨ ÏãúÏ†ê ÎßàÏª§
            current_price = df['price'].iloc[-1]
            fig.add_trace(
                go.Scatter(
                    x=[current_time],
                    y=[current_price],
                    mode='markers',
                    name='ÌòÑÏû¨ ÏãúÏ†ê',
                    marker=dict(color='red', size=15, symbol='diamond'),
                    hovertemplate='<b>ÌòÑÏû¨</b><br>%{x|%m/%d %H:%M}<br>$%{y:,.0f}<extra></extra>'
                ),
                row=1, col=1
            )
            
            # 4. AI ÏòàÏ∏°
            fig.add_trace(
                go.Scatter(
                    x=future_times,
                    y=future_prices,
                    mode='lines+markers',
                    name='AI ÏòàÏ∏° (6Í∞úÏõî ÌïôÏäµ)',
                    line=dict(color='#E74C3C', width=3, dash='dot'),
                    marker=dict(size=6, symbol='triangle-up'),
                    hovertemplate='<b>AI ÏòàÏ∏°</b><br>%{x|%m/%d %H:%M}<br>$%{y:,.0f}<br>Ïã†Î¢∞ÎèÑ: %{customdata:.1f}%<extra></extra>',
                    customdata=future_confidence
                ),
                row=1, col=1
            )
            
            # 5. Ïã†Î¢∞ Íµ¨Í∞Ñ
            fig.add_trace(
                go.Scatter(
                    x=future_times + future_times[::-1],
                    y=future_upper + future_lower[::-1],
                    fill='toself',
                    fillcolor='rgba(231,76,60,0.15)',
                    line=dict(color='rgba(255,255,255,0)'),
                    name='AI Ïã†Î¢∞Íµ¨Í∞Ñ',
                    hoverinfo='skip'
                ),
                row=1, col=1
            )
            
            # 6. Í±∞ÎûòÎüâ
            if 'volume' in recent_df.columns:
                fig.add_trace(
                    go.Bar(
                        x=recent_df['timestamp'],
                        y=recent_df['volume'] / 1e9,  # Ïñµ Îã®ÏúÑ
                        name='Í±∞ÎûòÎüâ (Ïã≠Ïñµ$)',
                        marker_color='lightblue',
                        opacity=0.6,
                        hovertemplate='<b>Í±∞ÎûòÎüâ</b><br>%{x|%m/%d}<br>%{y:.1f}Ïã≠Ïñµ$<extra></extra>'
                    ),
                    row=2, col=1
                )
            
            # 7. AI Ïã†Î¢∞ÎèÑ
            fig.add_trace(
                go.Scatter(
                    x=future_times,
                    y=future_confidence,
                    mode='lines+markers',
                    name='AI Ïã†Î¢∞ÎèÑ',
                    line=dict(color='#27AE60', width=2),
                    marker=dict(size=4),
                    hovertemplate='<b>AI Ïã†Î¢∞ÎèÑ</b><br>%{x|%m/%d %H:%M}<br>%{y:.1f}%<extra></extra>',
                    yaxis='y2'
                ),
                row=2, col=1
            )
            
            # 8. RSI
            if 'rsi' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['rsi'],
                        mode='lines',
                        name='RSI(14)',
                        line=dict(color='purple', width=1),
                        hovertemplate='<b>RSI</b><br>%{x|%m/%d}<br>%{y:.1f}<extra></extra>'
                    ),
                    row=3, col=1
                )
                
                # RSI Í≥ºÎß§Ïàò/Í≥ºÎß§ÎèÑ ÎùºÏù∏
                fig.add_hline(y=70, line=dict(color="red", dash="dash", width=1), row=3, col=1)
                fig.add_hline(y=30, line=dict(color="green", dash="dash", width=1), row=3, col=1)
            
            # 9. MACD
            if 'macd' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['macd'],
                        mode='lines',
                        name='MACD',
                        line=dict(color='blue', width=1),
                        hovertemplate='<b>MACD</b><br>%{x|%m/%d}<br>%{y:.1f}<extra></extra>',
                        yaxis='y4'
                    ),
                    row=3, col=1
                )
            
            # 10. Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            if 'bb_upper' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['bb_upper'],
                        mode='lines',
                        name='Î≥ºÎ¶∞Ï†Ä ÏÉÅÎã®',
                        line=dict(color='gray', width=1, dash='dot'),
                        hovertemplate='<b>BB ÏÉÅÎã®</b><br>%{x|%m/%d}<br>$%{y:,.0f}<extra></extra>'
                    ),
                    row=4, col=1
                )
                
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['bb_lower'],
                        mode='lines',
                        name='Î≥ºÎ¶∞Ï†Ä ÌïòÎã®',
                        line=dict(color='gray', width=1, dash='dot'),
                        hovertemplate='<b>BB ÌïòÎã®</b><br>%{x|%m/%d}<br>$%{y:,.0f}<extra></extra>'
                    ),
                    row=4, col=1
                )
            
            # 11. Î≥ÄÎèôÏÑ±
            if 'volatility' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['volatility'],
                        mode='lines',
                        name='Î≥ÄÎèôÏÑ±',
                        line=dict(color='red', width=1),
                        hovertemplate='<b>Î≥ÄÎèôÏÑ±</b><br>%{x|%m/%d}<br>%{y:.1%}<extra></extra>',
                        yaxis='y8'
                    ),
                    row=4, col=1
                )
            
            # 12. ÌôúÏÑ± Ï£ºÏÜå
            if 'active_addresses' in recent_df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=recent_df['timestamp'],
                        y=recent_df['active_addresses'],
                        mode='lines',
                        name='ÌôúÏÑ± Ï£ºÏÜå',
                        line=dict(color='green', width=1),
                        hovertemplate='<b>ÌôúÏÑ± Ï£ºÏÜå</b><br>%{x|%m/%d}<br>%{y:,.0f}<extra></extra>'
                    ),
                    row=5, col=1
                )
            
            # ÌòÑÏû¨ ÏãúÏ†ê ÏàòÏßÅÏÑ† (Î™®Îì† ÏÑúÎ∏åÌîåÎ°ØÏóê)
            for row in range(1, 6):
                fig.add_shape(
                    type="line",
                    x0=current_time, x1=current_time,
                    y0=0, y1=1,
                    yref="paper",
                    line=dict(color="red", width=1, dash="dash"),
                    row=row, col=1
                )
            
            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            model_info = f"ÏµúÍ≥† Î™®Îç∏: MAE ${model_results.get('mae', 0):,.0f} | " \
                        f"R¬≤ {model_results.get('r2', 0):.3f} | " \
                        f"Î∞©Ìñ•Ï†ïÌôïÎèÑ {model_results.get('direction_accuracy', 0):.1%}"
            
            fig.update_layout(
                title={
                    'text': f"""
                    <b>üöÄ BTC Í∂ÅÍ∑π ÏòàÏ∏° ÏãúÏä§ÌÖú v4.0</b><br>
                    <span style='font-size:14px'>
                    ÌòÑÏû¨: ${current_price:,.0f} | ÏÉùÏÑ±: {current_time.strftime('%Y-%m-%d %H:%M')}<br>
                    6Í∞úÏõî ÌïôÏäµ Îç∞Ïù¥ÌÑ∞: {len(df)}Ïùº | 48ÏãúÍ∞Ñ ÏòàÏ∏° | {model_info}
                    </span>
                    """,
                    'x': 0.5,
                    'font': {'size': 16}
                },
                height=1200,
                showlegend=True,
                template='plotly_white',
                hovermode='x unified'
            )
            
            # Ï∂ï ÏÑ§Ï†ï
            fig.update_xaxes(title_text="ÎÇ†Ïßú", tickformat="%m/%d", row=5, col=1)
            fig.update_yaxes(title_text="BTC Í∞ÄÍ≤© (USD)", row=1, col=1)
            fig.update_yaxes(title_text="Í±∞ÎûòÎüâ", row=2, col=1)
            fig.update_yaxes(title_text="Ïã†Î¢∞ÎèÑ (%)", secondary_y=True, range=[0, 100], row=2, col=1)
            fig.update_yaxes(title_text="RSI", range=[0, 100], row=3, col=1)
            fig.update_yaxes(title_text="MACD", secondary_y=True, row=3, col=1)
            fig.update_yaxes(title_text="BB Í∞ÄÍ≤©", row=4, col=1)
            fig.update_yaxes(title_text="Î≥ÄÎèôÏÑ±", secondary_y=True, row=4, col=1)
            fig.update_yaxes(title_text="ÌôúÏÑ± Ï£ºÏÜå", row=5, col=1)
            
            # Ï†ÄÏû•
            chart_path = os.path.join(self.base_path, "ultimate_btc_prediction_chart.html")
            fig.write_html(chart_path)
            
            print(f"‚úÖ Í∂ÅÍ∑π Ï∞®Ìä∏ Ï†ÄÏû•: {chart_path}")
            return chart_path
            
        except Exception as e:
            print(f"‚ùå Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return ""
    
    def print_ultimate_results(self, df: pd.DataFrame, predictions: List[Dict], 
                              model_results: Dict):
        """Í∂ÅÍ∑πÏùò Í≤∞Í≥º Ï∂úÎ†•"""
        print("\n" + "="*80)
        print("üöÄ BTC Í∂ÅÍ∑π ÏòàÏ∏° ÏãúÏä§ÌÖú Í≤∞Í≥º")
        print("="*80)
        
        current_price = df['price'].iloc[-1]
        current_time = datetime.now()
        
        # Í∏∞Î≥∏ Ï†ïÎ≥¥
        print(f"üí∞ ÌòÑÏû¨ Í∞ÄÍ≤©: ${current_price:,.0f}")
        print(f"üïê Î∂ÑÏÑù ÏãúÍ∞Ñ: {current_time.strftime('%Y-%m-%d %H:%M')}")
        print(f"üìä ÌïôÏäµ Îç∞Ïù¥ÌÑ∞: {len(df)}Ïùº (6Í∞úÏõî ÏãúÍ≥ÑÏó¥)")
        
        # Î™®Îç∏ ÏÑ±Îä•
        print(f"\nü§ñ AI Î™®Îç∏ ÏÑ±Îä•:")
        print(f"  ‚Ä¢ ÌèâÍ∑† Ïò§Ï∞®: ${model_results.get('mae', 0):,.0f}")
        print(f"  ‚Ä¢ R¬≤ Ï†êÏàò: {model_results.get('r2', 0):.3f}")
        print(f"  ‚Ä¢ Î∞©Ìñ• Ï†ïÌôïÎèÑ: {model_results.get('direction_accuracy', 0):.1%} ‚≠ê")
        
        # ÏòàÏ∏° ÏöîÏïΩ
        if predictions:
            pred_24h = next((p for p in predictions if p['hour'] == 24), predictions[-1])
            pred_48h = predictions[-1]
            
            print(f"\nüîÆ AI ÏòàÏ∏° Í≤∞Í≥º:")
            print(f"  ‚Ä¢ 24ÏãúÍ∞Ñ ÌõÑ: ${pred_24h['price']:,.0f} ({pred_24h['change_from_current']:+.2f}%)")
            print(f"  ‚Ä¢ 48ÏãúÍ∞Ñ ÌõÑ: ${pred_48h['price']:,.0f} ({pred_48h['change_from_current']:+.2f}%)")
            print(f"  ‚Ä¢ ÌèâÍ∑† Ïã†Î¢∞ÎèÑ: {np.mean([p['confidence'] for p in predictions])*100:.1f}%")
        
        # Ï£ºÏöî ÏãúÏ†ê ÏòàÏ∏°
        print(f"\n‚è∞ Ï£ºÏöî ÏãúÏ†êÎ≥Ñ ÏòàÏ∏°:")
        key_hours = [6, 12, 24, 36, 48]
        for hour in key_hours:
            pred = next((p for p in predictions if p['hour'] == hour), None)
            if pred:
                time_str = pred['timestamp'].strftime("%m/%d %H:%M")
                print(f"  ‚Ä¢ {hour:2d}ÏãúÍ∞Ñ ÌõÑ ({time_str}): ${pred['price']:,.0f} "
                      f"({pred['change_from_current']:+.2f}%) [Ïã†Î¢∞ÎèÑ: {pred['confidence']*100:.1f}%]")
        
        print("\n" + "="*80)
        print("üéâ 6Í∞úÏõî ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Í∂ÅÍ∑π ÏòàÏ∏° ÏôÑÎ£å!")
        print("="*80)
    
    async def run_ultimate_system(self):
        """Í∂ÅÍ∑π ÏãúÏä§ÌÖú Ïã§Ìñâ"""
        print("üöÄ BTC Í∂ÅÍ∑π ÏòàÏ∏° ÏãúÏä§ÌÖú v4.0 ÏãúÏûë")
        print("="*80)
        
        # 1. 6Í∞úÏõî Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        df = self.load_6month_timeseries_data()
        if df.empty:
            print("‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®")
            return None
        
        # 2. Í≥†Í∏â ÏßÄÌëú Í≥ÑÏÇ∞
        df = self.calculate_advanced_indicators(df)
        
        # 3. AI Î™®Îç∏ ÌõàÎ†®
        model_info = self.train_prediction_model(df)
        best_model, feature_cols, all_results = model_info
        
        if not best_model:
            print("‚ùå Î™®Îç∏ ÌõàÎ†® Ïã§Ìå®")
            return None
        
        # 4. ÎØ∏Îûò ÏòàÏ∏°
        predictions = self.generate_future_predictions(df, model_info, hours_ahead=48)
        
        if not predictions:
            print("‚ùå ÏòàÏ∏° ÏÉùÏÑ± Ïã§Ìå®")
            return None
        
        # 5. Í∂ÅÍ∑πÏùò Ï∞®Ìä∏ ÏÉùÏÑ±
        chart_path = self.create_ultimate_chart(df, predictions, best_model)
        
        # 6. Í≤∞Í≥º Ï∂úÎ†•
        self.print_ultimate_results(df, predictions, best_model)
        
        # 7. Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïó¥Í∏∞
        if chart_path:
            try:
                import subprocess
                subprocess.run(["open", chart_path])
                print(f"\nüåê Í∂ÅÍ∑πÏùò Ï∞®Ìä∏Í∞Ä Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïó¥Î†∏ÏäµÎãàÎã§!")
            except:
                print(f"\nüí° Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÌôïÏù∏: {chart_path}")
        
        return {
            'dataframe': df,
            'predictions': predictions,
            'model_results': best_model,
            'chart_path': chart_path
        }

async def main():
    """Î©îÏù∏ Ïã§Ìñâ"""
    system = UltimatePredictionChart()
    result = await system.run_ultimate_system()
    
    if result:
        print("\n‚úÖ Í∂ÅÍ∑π ÏòàÏ∏° ÏãúÏä§ÌÖú ÏôÑÎ£å!")
    else:
        print("\n‚ùå ÏãúÏä§ÌÖú Ïã§Ìñâ Ïã§Ìå®")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())